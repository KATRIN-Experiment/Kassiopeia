#ifdef KEMFIELD_USE_CL_VECTOR
#define CL_HPP_NO_STD_VECTOR  // Use cl::vector instead of STL version
#define CL_VECTOR_TYPE cl::vector
#else
#define CL_VECTOR_TYPE std::vector
#endif

#define CL_HPP_ENABLE_EXCEPTIONS

// use OpenCL 1.2 definitions - higher version are not working correctly
#define CL_HPP_MINIMUM_OPENCL_VERSION 110
#define CL_HPP_TARGET_OPENCL_VERSION 120

#if defined __APPLE__
#include <OpenCL/cl2.hpp>
#else
#include <CL/cl2.hpp>
#endif

#include <algorithm>
#include <cmath>
#include <exception>
#include <fstream>
#include <iostream>
#include <iterator>
#include <limits>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

#define DATA_SIZE (10240)

const char* KernelSource = "\n"
                           "#ifdef AMD                                                              \n"
                           "#pragma OPENCL EXTENSION cl_amd_fp64 : enable                           \n"
                           "#else                                                                   \n"
                           "#pragma OPENCL EXTENSION cl_khr_fp64 : enable                           \n"
                           "#endif /* AMD */                                                        \n"
                           "                                                                        \n"
                           "double ArcSinh(double x)                                                \n"
                           "{                                                                       \n"
                           "  return log(x + sqrt(1. + x*x));                                       \n"
                           "}                                                                       \n"
                           "                                                                        \n"
                           "__kernel void vector_ArcSinh(                                           \n"
                           "   __global double* input,                                              \n"
                           "   __global double* output,                                             \n"
                           "   __global int* count)                                                 \n"
                           "{                                                                       \n"
                           "   int i = get_global_id(0);                                            \n"
                           "   if (i<count[0])                                                      \n"
                           "     output[i] = ArcSinh(input[i]);                                     \n"
                           "}                                                                       \n"
                           "\n";

const char* KernelSource_f = "\n"
                             "                                                                       \n"
                             "__kernel void vector_ArcSinh(                                          \n"
                             "   __global float* input,                                              \n"
                             "   __global float* output,                                             \n"
                             "   __global int* count)                                                \n"
                             "{                                                                      \n"
                             "   int i = get_global_id(0);                                           \n"
                             "   if(i < count[0])                                                    \n"
                             "       output[i] = 1./fabs(input[i]);                                  \n"
                             "}                                                                      \n"
                             "\n";

int main()
{
    // ifdef-guard header
    std::cout << "#ifndef KEMFIELD_OPENCL_DEFINES_H" << std::endl;
    std::cout << "#define KEMFIELD_OPENCL_DEFINES_H" << std::endl;
    std::cout << "" << std::endl;
    std::cout << "/* NOTE: this file has been autogenerated by the program \"GenerateOpenCLHeader\"" << std::endl;
    std::cout << "         at build time.  Any changes to this file will be erased when KEMField" << std::endl;
    std::cout << "         is re-installed! */" << std::endl;
    std::cout << std::endl;

    // Set up list of desired extensions
    std::vector<std::string> desired_extensions;
    desired_extensions.push_back(((std::string) "cl_khr_fp64"));
    desired_extensions.push_back(((std::string) "cl_amd_fp64"));

    // Create flag for double precision support
    bool double_precision = false;

    // Default GPU to use (if more than one are present)
    unsigned int defaultDeviceID = 0;

    // Get available platforms
    CL_VECTOR_TYPE<cl::Platform> platforms;
    cl::Platform::get(&platforms);
    if (platforms.size() == 0) {
      std::cout << "No platforms available" << std::endl;
      return -1;
    }
    else if (platforms.size() <= KEMFIELD_OPENCL_PLATFORM) {
      std::cout << "Platform not found: " << KEMFIELD_OPENCL_PLATFORM << std::endl;
      return -1;
    }

    std::cout << "/* Generated using platform #" << KEMFIELD_OPENCL_PLATFORM << " out of " << platforms.size()
              << " platforms. */" << std::endl;
    std::cout << std::endl;

    // Select the default platform and create a context using this platform and the GPU
    cl_context_properties cps[3] = {CL_CONTEXT_PLATFORM,
                                    (cl_context_properties)(platforms[KEMFIELD_OPENCL_PLATFORM])(),
                                    0};

    int deviceType = KEMFIELD_OPENCL_DEVICE_TYPE;

    cl::Context* context = NULL;

    if (deviceType < 0)  //we don't know
    {
        context = new cl::Context(CL_DEVICE_TYPE_ALL, cps);
    }

    if (deviceType == 0)  //we have a GPU
    {
        context = new cl::Context(CL_DEVICE_TYPE_GPU, cps);
    }

    if (deviceType == 1)  //we have a CPU
    {
        context = new cl::Context(CL_DEVICE_TYPE_CPU, cps);
    }

    if (deviceType == 2)  //we have an accelerator device
    {
        context = new cl::Context(CL_DEVICE_TYPE_ACCELERATOR, cps);
    }

    // Get a list of devices on this platform
    CL_VECTOR_TYPE<cl::Device> devices = context->getInfo<CL_CONTEXT_DEVICES>();

    std::cout << "/*" << std::endl;
    std::cout << " Number of available platforms on this machine: " << platforms.size() << std::endl;
    for (unsigned int i = 0; i < platforms.size(); i++) {
        std::cout << " Platform #" << i << std::endl;
        std::cout << "   Name:           " << platforms[i].getInfo<CL_PLATFORM_NAME>() << std::endl;
        std::cout << "   Vendor:         " << platforms[i].getInfo<CL_PLATFORM_VENDOR>() << std::endl;
        std::cout << "   Profile:        " << platforms[i].getInfo<CL_PLATFORM_PROFILE>() << std::endl;
        std::cout << "   Version:        " << platforms[i].getInfo<CL_PLATFORM_VERSION>() << std::endl;
    }
    std::cout << std::endl;
    std::cout << " Available devices on platform #" << KEMFIELD_OPENCL_PLATFORM << " : " << devices.size() << std::endl;
    for (unsigned int i = 0; i < devices.size(); i++) {
        std::cout << " Device #" << i << std::endl;
        std::cout << "   Name:           " << devices[i].getInfo<CL_DEVICE_NAME>() << std::endl;
        std::cout << "   Type:           " << devices[i].getInfo<CL_DEVICE_TYPE>() << " (1=CPU, 2=GPU, 3=Acc, 4=Custom)" << std::endl;
        std::cout << "   Vendor:         " << devices[i].getInfo<CL_DEVICE_VENDOR>() << std::endl;
        std::cout << "   Profile:        " << devices[i].getInfo<CL_DEVICE_PROFILE>() << std::endl;
        std::cout << "   Version:        " << devices[i].getInfo<CL_DEVICE_VERSION>() << std::endl;
        std::cout << "   Driver Version: " << devices[i].getInfo<CL_DRIVER_VERSION>() << std::endl;
        std::cout << "   Extensions:     " << devices[i].getInfo<CL_DEVICE_EXTENSIONS>() << std::endl;
        std::cout << "   Global Memory:  " << devices[i].getInfo<CL_DEVICE_GLOBAL_MEM_SIZE>()/1024 << " (KiB)" << std::endl;
        std::cout << "   Local Memory:   " << devices[i].getInfo<CL_DEVICE_LOCAL_MEM_SIZE>()/1024 << " (KiB)" << std::endl;
    }
    std::cout << "*/" << std::endl;
    std::cout << std::endl;

    std::stringstream options;

    for (unsigned int i = 0; i < devices.size(); i++) {
        std::string device_ext_list = devices[i].getInfo<CL_DEVICE_EXTENSIONS>();

        std::istringstream iss(device_ext_list);
        std::vector<std::string> device_extensions;
        std::copy(std::istream_iterator<std::string>(iss),
                  std::istream_iterator<std::string>(),
                  std::back_inserter<std::vector<std::string>>(device_extensions));

        for (unsigned int j = 0; j < device_extensions.size(); j++) {
            for (unsigned int k = 0; k < desired_extensions.size(); k++) {
                if (device_extensions[j] == desired_extensions[k]) {
                    std::cout << "#pragma OPENCL EXTENSION " << device_extensions[j] << " : enable" << std::endl;
                    desired_extensions[k] = "NULL";
                    if (strstr(device_extensions[j].c_str(), "amd"))
                        options << "-DAMD";
                    if (strstr(device_extensions[j].c_str(), "fp64"))
                        double_precision = true;
                    defaultDeviceID = i;
                }
            }
        }
    }
    std::cout << std::endl;

    std::cout << "/* Selected device #" << defaultDeviceID << " out of " << devices.size()
              << " on this platform. */" << std::endl;
    std::cout << std::endl;

    // Select the default platform and create a context using this platform and the GPU
    // Create a new devices vector with only the default one in it
    cl::Device defaultDevice = devices[defaultDeviceID];
    devices.clear();
    devices.push_back(defaultDevice);

    std::cout << "#define KEMFIELD_DEFAULT_GPU_ID " << defaultDeviceID << std::endl;

    if (double_precision) {
        std::cout << "#define KEMFIELD_USE_DOUBLE_PRECISION" << std::endl;
        std::cout << "#define CL_TYPE double" << std::endl;
        std::cout << "#define CL_TYPE2 double2" << std::endl;
        std::cout << "#define CL_TYPE4 double4" << std::endl;
        std::cout << "#define CL_TYPE8 double8" << std::endl;
        std::cout << "#define CL_TYPE16 double16" << std::endl;
    }
    else {
        std::cout << "#undef KEMFIELD_USE_DOUBLE_PRECISION  /* not supported on any device */" << std::endl;
        std::cout << "#define CL_TYPE float" << std::endl;
        std::cout << "#define CL_TYPE2 float2" << std::endl;
        std::cout << "#define CL_TYPE4 float4" << std::endl;
        std::cout << "#define CL_TYPE8 float8" << std::endl;
        std::cout << "#define CL_TYPE16 float16" << std::endl;
    }

    if (!double_precision && platforms[0].getInfo<CL_PLATFORM_NAME>() == "Apple") {
        // we must recast sqrt() to take only floats
        std::cout << "#define SQRT(x) sqrt((float)(x))" << std::endl;
        std::cout << "#define LOG(x) log((float)(x))" << std::endl;
    }
    else
    {
        std::cout << "#define SQRT(x) sqrt(x)" << std::endl;
        std::cout << "#define LOG(x) log(x)" << std::endl;
    }

    // definition of constants
    std::cout << "#define M_EPS0 8.854187817E-12" << std::endl;
    std::cout << "#define M_PI_OVER_2 1.57079632679489661923" << std::endl;
    std::cout << "#define M_ONEOVER_4PI_EPS0 8987551787.9979107161559640186992" << std::endl;

    // mathematical operations
    std::cout << "#define POW2(x) ((x)*(x))" << std::endl;
    std::cout << "#define POW3(x) ((x)*(x)*(x))" << std::endl;

    int* count = new int[1];
    count[0] = DATA_SIZE;

    double arcSinhInputs[DATA_SIZE];
    double arcSinhOutputs[DATA_SIZE];
    float arcSinhInputs_f[DATA_SIZE];
    float arcSinhOutputs_f[DATA_SIZE];

    for (unsigned int i = 0; i < DATA_SIZE; i++) {
        arcSinhInputs[i] = -pow(2, i);
        arcSinhInputs_f[i] = exp((double) i);
    }

    // Create a command queue and use the first device
    cl::CommandQueue queue = cl::CommandQueue(*context, devices[0]);

    // Source file
    std::string sourceCode;
    if (double_precision)
        sourceCode = KernelSource;
    else
        sourceCode = KernelSource_f;

    cl::Program::Sources source = {{sourceCode.c_str(), sourceCode.length() + 1}};

    // Make program of the source code in the context
    cl::Program program = cl::Program(*context, source);

    // Build program for these specific devices
    try {
        program.build(devices, options.str().c_str());
    }
    catch (cl::Error& error) {
        std::cerr << "There was an error compiling the kernels.  Here is the information from the OpenCL C++ API:"
                  << std::endl;
        std::cerr << error.what() << "(" << error.err() << ")" << std::endl;
        std::cerr << "Build Status: " << program.getBuildInfo<CL_PROGRAM_BUILD_STATUS>(devices[0]) << std::endl;
        std::cerr << "Build Options:\t" << program.getBuildInfo<CL_PROGRAM_BUILD_OPTIONS>(devices[0]) << std::endl;
        std::cerr << "Build Log:\t " << program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(devices[0]);
        return -1;
    }

    // Make kernel
    cl::Kernel kernel(program, "vector_ArcSinh");

    // Create memory buffers
    cl::Buffer* bufferIn;
    cl::Buffer* bufferOut;
    if (double_precision) {
        bufferIn = new cl::Buffer(*context, CL_MEM_READ_ONLY, DATA_SIZE * sizeof(double));
        bufferOut = new cl::Buffer(*context, CL_MEM_WRITE_ONLY, DATA_SIZE * sizeof(double));
    }
    else {
        bufferIn = new cl::Buffer(*context, CL_MEM_READ_ONLY, DATA_SIZE * sizeof(cl_mem));
        bufferOut = new cl::Buffer(*context, CL_MEM_WRITE_ONLY, DATA_SIZE * sizeof(cl_mem));
    }

    cl::Buffer bufferCount = cl::Buffer(*context, CL_MEM_READ_ONLY, sizeof(int));

    // Copy in buffer to the memory buffer
    if (double_precision)
        queue.enqueueWriteBuffer(*bufferIn, CL_TRUE, 0, DATA_SIZE * sizeof(double), arcSinhInputs);
    else
        queue.enqueueWriteBuffer(*bufferIn, CL_TRUE, 0, DATA_SIZE * sizeof(cl_mem), arcSinhInputs_f);

    queue.enqueueWriteBuffer(bufferCount, CL_TRUE, 0, sizeof(int), count);

    // Set arguments to kernel
    kernel.setArg(0, *bufferIn);
    kernel.setArg(1, *bufferOut);
    kernel.setArg(2, bufferCount);

    // Run the kernel on specific ND range
    cl::NDRange global(DATA_SIZE);
    cl::NDRange local(1);
    queue.enqueueNDRangeKernel(kernel, cl::NullRange, global, local);

    // Read out buffer into a local list
    if (double_precision)
        queue.enqueueReadBuffer(*bufferOut, CL_TRUE, 0, DATA_SIZE * sizeof(double), arcSinhOutputs);
    else {
        queue.enqueueReadBuffer(*bufferOut, CL_TRUE, 0, DATA_SIZE * sizeof(cl_mem), arcSinhOutputs_f);
        for (int i = 0; i < DATA_SIZE; i++)
            arcSinhOutputs[i] = arcSinhOutputs_f[i];
    }

    // we still don't need this type of functionality yet, but eventually it would
    // be great to experimentally query the card for its limits for certain
    // math functions, and insert them into the OpenCL code
    for (unsigned int i = 0; i < DATA_SIZE; i++)
        if (arcSinhOutputs[i] != arcSinhOutputs[i] ||
            fabs(arcSinhOutputs[i]) == std::numeric_limits<double>::infinity() || arcSinhOutputs[i] == 0.) {
            std::cout << "#define MAX_ASINH_ARG " << arcSinhInputs[i-1]<<std::endl;
            break;
        }

    queue.finish();

    delete bufferIn;
    delete bufferOut;

    // complete ifdef-guard header
    std::cout << std::endl;
    std::cout << "#endif /* KEMFIELD_OPENCL_DEFINES_H */" << std::endl;

    delete context;

    return 0;
}
